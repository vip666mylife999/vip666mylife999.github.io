<!DOCTYPE html>
<html lang='en-US'>
<head>
<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0">
<base href="https://vip666mylife999.github.io/">
<link rel="icon" href="assets/hcpp-icon.png">
<link rel="stylesheet" type="text/css" href="assets/style.css?v=26">
<link rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
<title>h/cpp - Comparing Custom Types</title>
<meta name="description" content="Learn how to write simple comparison operations in C++ by overloading operators; including the brand-new <q>spaceship operator</q> for 3-way comparisons.">
<meta name="keyword" content="cpp design types operations operators 2-way 3-way spaceship category compare comparison equal equality inequality equivalent relational equivalence smaller larger less greater order ordering">
<meta name="author" content="André Müller">
<meta name="date" content="2021-01-31">
<meta name="copyright" content="2019-2021&ensp;André Müller">
<meta name="hcpp-page-category" content="cat-article">
<meta name="hcpp-tags" content="C++ C++20 article beginner-level classes comparisons custom-types types ">
</head>
<body>
<div id="top-nav"><div id="titlebar" class="boxed-wide"><div id="main-branding">
<a href="index.html"  id="main-logo" title="home"><span class="hwide"><img src="assets/hcpp.svg" style="max-width:100%;height:40;"></img></span>
<span class="hslim"><img src="assets/hcpp-square.svg" style="max-width:100%;height:40;"></img></span></a>

<div id="main-title">
<a href="index.html"  title="home">hacking&nbsp;C++</a>
</div></div>
<div id="main-menu"><div class="entry "><a href="tags/news.html">News</a></div>
<div class="submenu "><a>Learning</a><div class="submenu-dropdown">
<a href="cpp/beginners_guide.html" >Beginner's Guide to C++</a>

<hr>

<a href="cpp/std/containers.html" >Standard Library Containers</a>


<a href="cpp/std/algorithms.html" >Standard Library Algorithms</a>

<hr>

<a href="cpp/cheat_sheets.html" >Infographics / Cheat Sheets</a>


<a href="tags/article.html" >All Articles</a>

<hr>

<a href="dev/web_learning.html" >Online Learning</a>


<a href="cpp/books.html" >Books</a>
</div></div>
<div class="submenu "><a>Links</a><div class="submenu-dropdown">
<a href="cpp/community.html" >Community Resources</a>


<a href="cpp/tools/ecosystem.html" >Tool Ecosystem</a>

<hr>

<a href="tags/list.html" >All Resource Lists</a>

<hr>

<a href="dev/vim_plugins.html" >VIM Plugins</a>
</div></div>
<div class="submenu "><a>About</a><div class="submenu-dropdown">
<a href="about.html" >Why &amp; Who</a>


<a href="privacy.html" >Privacy</a>
</div></div></div>
<div id="main-socialbar">
<a href="https://twitter.com/hackingcpp" ><span class="cat-twitter"></span></a>
</div>
<div class="navlinks" id="nav-path"></div>
<div id="searchbar"><div id="searchbox"><input id="search-input"></input>
<button id="search-clear"></button>
<button id="search-run"></button>
<button id="search-close"></button></div></div>
<div class="hamburger " id="main-hamburger"><button title=""></button><div class="hamburger-dropdown"><a class="nav-icon-collapse-all" onclick="collapse_all_major_folds()">Collapse <strong>All</strong> Levels</a>

<a class="nav-icon-collapse" onclick="collapse_major_folds()">Collapse Top Level</a>

<a class="nav-icon-expand" onclick="expand_major_folds()">Expand Top Level</a>

<a class="nav-icon-expand-all" onclick="expand_all_major_folds()">Expand <strong>All</strong> Levels</a>

<hr>

<a href="tags/news.html" class="cat-news" >News</a>


<a href="tags/featured.html" class="cat-featured" >Featured</a>


<a href="tags/article.html" class="cat-article" >Articles</a>


<a href="cpp/beginners_guide.html" class="cat-guide" >Beginner's Guide to C++</a>


<a href="tags/list.html" class="cat-list" >Lists</a>

<hr>

<a href="https://twitter.com/hackingcpp" ><span class="cat-twitter"></span> @hackingcpp</a>


<a href="about.html" class="cat-about" >About</a>


<a href="privacy.html" class="cat-contact" >Privacy</a>


<a href="index.html" class="cat-home" >Home</a>
</div></div></div>
<nav id="guide-bar" class="boxed-wide"><div class="guide-nav">
<div class="go-prev"><a href="cpp/lang/friends.html"><span class="hwide">friend</span></a></div>
<div class="go-up"><a href="cpp/beginners_guide.html#custom-types-1">Beginner's Guide <span class="hxwide">/ Custom Types 1</span></a></div>
<div class="go-next"><a href="cpp/design/literal_types.html"><span class="hwide">Literal Types</span></a></div>
</div></nav></div>
<div id="drawer-top" class="boxed-wide"><div id="search-results"><div id="search-header"><h1 class="cat-search" id="search-title"></h1></div>
<div id="search-locations"><ul class="resources" id="search-location-items"></ul></div>
<div id="search-footer"></div></div></div>
<div id="drawer-left"><div id="drawer-left-heading"><a class="cat-guide" href="cpp/beginners_guide.html#intro">Beginner's Guide</a></div>
<div id="drawer-left-content"><div class="tree-fold plain" ><h5>First Steps</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/tools/beginner_dev_setup.html" >Development Setup</a>
</li>
<hr>

<li>
<a href="cpp/hello_world.html" >Hello World</a>
</li>

<li>
<a href="cpp/std/io_basics.html" >Input &amp; Output <small>(Basics)</small></a>
</li>

<li>
<a href="cpp/lang/fundamental_types.html" >Fundamental Types</a>
</li>

<li>
<a href="cpp/std/vector_intro.html" >std::vector Introduction</a>
</li>

<li>
<a href="cpp/lang/enumerations.html" >Enumerations</a>
</li>
<hr>

<li>
<a href="cpp/lang/control_flow_basics.html" >Control Flow <small>(Basics)</small></a>
</li>

<li>
<a href="cpp/lang/type_system_basics.html" >Type System <small>(Basics)</small></a>
</li>

<li>
<a href="cpp/lang/function_basics.html" >Functions <small>(Basics)</small></a>
</li>

<li>
<a href="cpp/lang/memory_basics.html" >Memory <small>(Basics)</small></a>
</li>
<hr>

<li>
<a href="cpp/std/string_basics.html" >String <small>(Basics)</small></a>
</li>

<li>
<a href="cpp/lang/references.html" >References</a>
</li>

<li>
<a href="cpp/lang/aggregates.html" >Simple Aggregates</a>
</li>

<li>
<a href="cpp/lang/function_call_mechanics.html" >Function Call Mechanics</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Input &amp; Output</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/command_line_arguments.html" >Command Line Arguments</a>
</li>

<li>
<a href="cpp/std/file_streams.html" >File Input &amp; Output</a>
</li>

<li>
<a href="cpp/std/io_streams.html" >Stream Input &amp; Output</a>
</li>

<li>
<a href="cpp/std/istream_recover_from_errors.html" >Recover From Input Errors</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Custom Types &ndash; Part 1</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/custom_type_basics.html" >Simple Classes / Custom Types</a>
</li>
<hr>

<li>
<a href="cpp/lang/pointers.html" >Pointers</a>
</li>

<li>
<a href="cpp/lang/destructors.html" >Destructors</a>
</li>
<hr>

<li>
<a href="cpp/lang/exceptions.html" >Exceptions</a>
</li>

<li>
<a href="cpp/lang/noexcept.html" >Noexcept</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Diagnostics</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/tools/compiler_warnings.html" >Compiler Warnings</a>
</li>

<li>
<a href="cpp/tools/gdb_intro.html" >Debugging With gdb</a>
</li>

<li>
<a href="cpp/tools/asan.html" >Address Sanitizer</a>
</li>

<li>
<a href="cpp/tools/ubsan.html" >Undefined Behavior Sanitizer</a>
</li>

<li>
<a href="cpp/tools/valgrind.html" >valgrind</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Standard Library</h5></div>
<div class="content " ><div class="tree-fold plain" ><h6>Containers &amp; Views</h6></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/std/iterators_intro.html" >Iterators</a>
</li>

<li>
<a href="cpp/std/sequence_containers.html" >Sequence Containers</a>
</li>

<li>
<a href="cpp/std/sequence_views.html" >Sequence Views</a>
</li>

<li>
<a href="cpp/std/associative_containers.html" >Associative Containers</a>
</li></ul></div>
<div class="tree-fold plain" ><h6>Standard Algorithms</h6></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/std/algorithms/intro.html" >Basic Paradigms</a>
</li>

<li>
<a href="cpp/std/container_traversal.html" >Container Traversal</a>
</li>
<hr>

<li>
<a href="cpp/std/algorithms/min_max.html" >Minimum / Maximum</a>
</li>

<li>
<a href="cpp/std/algorithms/existence_queries.html" >Existence Queries</a>
</li>

<li>
<a href="cpp/std/algorithms/finding.html" >Finding Elements</a>
</li>

<li>
<a href="cpp/std/algorithms/comparing_ranges.html" >Comparing Ranges</a>
</li>
<hr>

<li>
<a href="cpp/design/function_objects.html" >Function Objects</a>
</li>

<li>
<a href="cpp/lang/lambda_basics.html" >Lambdas <small>(Basics)</small></a>
</li>
<hr>

<li>
<a href="cpp/std/algorithms/reordering.html" >Sequence Reordering</a>
</li>

<li>
<a href="cpp/std/algorithms/element_modification.html" >Changing Elements</a>
</li>

<li>
<a href="cpp/std/algorithms/numeric.html" >Numeric Algorithms</a>
</li>

<li>
<a href="cpp/std/algorithms/sorted_sequence_operations.html" >Sorted Sequence Operations</a>
</li></ul></div>
<div class="tree-fold plain" ><h6>Utilities</h6></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/std/special_containers.html" >Special Containers</a>
</li>

<li>
<a href="cpp/std/special_iterators.html" >Special Iterators</a>
</li>

<li>
<a href="cpp/std/random.html" >Random Numbers</a>
</li></ul></div></div>
<div class="tree-fold plain" ><h5>Code Organization</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/separate_compilation.html" >Separate Compilation</a>
</li>

<li>
<a href="cpp/lang/namespaces.html" >Namespaces</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Custom Types &ndash; Part 2</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/friends.html" >Friends</a>
</li>

<li>
<a href="cpp/lang/comparisons.html" >Comparisons</a>
</li>

<li>
<a href="cpp/design/literal_types.html" >Literal Types</a>
</li>

<li>
<a href="cpp/design/arithmetic_types.html" >Arithmetic Types</a>
</li>
<hr>

<li>
<a href="cpp/std/unique_ownership.html" >Unique Resource Ownership</a>
</li>

<li>
<a href="cpp/design/node_based_data_structures.html" >Node-Based Data Structures</a>
</li>

<li>
<a href="cpp/lang/special_class_members.html" >Special Class Members</a>
</li>

<li>
<a href="cpp/std/shared_ownership.html" >Shared Resource Ownership</a>
</li>
<hr>

<li>
<a href="cpp/lang/object_oriented_programming.html" >Object Oriented Programming</a>
</li>
<hr>

<li>
<a href="cpp/lang/move_semantics.html" >Move Semantics</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Generic Programming</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/templates.html" >Templates</a>
</li>

<li>
<a href="cpp/lang/type_casts.html" >Type Casts</a>
</li>

<li>
<a href="cpp/lang/type_deduction.html" >Type Deduction</a>
</li>

<li>
<a href="cpp/std/type_traits.html" >Type Traits</a>
</li>

<li>
<a href="cpp/lang/perfect_forwarding.html" >Perfect Forwarding</a>
</li>

<li>
<a href="cpp/lang/concepts.html" >Concepts &amp; Constrained Templates</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Memory Management</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/lang/pointer_arithmetic.html" >Pointer Arithmetic</a>
</li>

<li>
<a href="cpp/lang/c_arrays.html" >C-Style Arrays</a>
</li>

<li>
<a href="cpp/lang/manual_memory_management.html" >Manual Memory Management</a>
</li>

<li>
<a href="cpp/design/allocators.html" >Allocators</a>
</li></ul></div>
<div class="tree-fold plain" ><h5>Software Design Basics</h5></div>
<div class="content " ><ul class="plain ">
<li>
<a href="cpp/design/principles.html" >Design Principles</a>
</li>

<li>
<a href="cpp/design/function_interface_example1.html" >Design Study: Function Interfaces</a>
</li>

<li>
<a href="cpp/design/angle_axis_rotation.html" >Design Study: Angle-Axis Rotation</a>
</li>

<li>
<a href="cpp/design/traversal_approaches.html" >Traversal Approaches</a>
</li>

<li>
<a href="cpp/design/pimpl.html" >The PIMPL Idiom</a>
</li></ul></div></div>
<button id="drawer-left-toggle" title=""></button></div>
<div id="main-content" class="boxed-wide "><article class="boxed-normal ">
<header class="plain">
<h1>
<span class="hwide">Comparing Custom Types</span><span class="hslim">Custom Comparisons</span><span class="hnavi">Comparing</span></h1>
<nav id="page-navbar" class=""></nav>
<div class="panel "><h5 class="hfold nav-none" open>Comparison operators 
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> and <code>&lt;=&gt;</code>
can be overloaded for custom types using operator functions<span class="if-opened">:</span></h5>
<div class="content " ><h6><a class="" href="cpp/lang/comparisons.html#equality-comparisons" onclick="reveal_anchor()">

Equality:
</a>&emsp; <q>Does&nbsp;A&nbsp;have&nbsp;the&nbsp;same&nbsp;value&nbsp;as&nbsp;B?</q></h6>
<div class="block ">
<pre class="notranslate"><code>bool <strong>operator</strong> <span class="e1">==</span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// equal</span>
bool <strong>operator</strong> <span class="e1">!=</span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// not equal</span></code></pre>
</div>
<h6><a class="" href="cpp/lang/comparisons.html#ordering-comparisons" onclick="reveal_anchor()">

Ordering:
</a>&emsp; <q>Does&nbsp;A&nbsp;go&nbsp;before/after&nbsp;B?</q></h6>
<div class="block ">
<pre class="notranslate"><code>bool <strong>operator</strong> <span class="e1">&lt; </span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// smaller</span>
bool <strong>operator</strong> <span class="e1">&lt;=</span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// smaller equal</span>
bool <strong>operator</strong> <span class="e1">&gt; </span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// greater</span>
bool <strong>operator</strong> <span class="e1">&gt;=</span> (<span class="annotation">&hellip;</span>)  <span class="comment ">// greater equal</span></code></pre>
</div>
<h6><a class="" href="cpp/lang/comparisons.html#three-way-comparisons" onclick="reveal_anchor()">

3-Way Comparison
</a> <div class="labels "><a class="lbl " href="tags/c++20.html">C++20</a></div></h6>
<div class="block ">
<pre class="notranslate"><code>auto <strong>operator</strong> <span class="e1">&lt;=&gt;</span> (<span class="annotation">&hellip;</span>)  <span class="comment ">//&nbsp;combines&nbsp;==&nbsp;!=&nbsp;&lt;&nbsp;&lt;=&nbsp;&gt;&nbsp;&gt;=</span></code></pre>
</div>
<hr>
<h6>Comparison functions are not automatically generated by the compiler:</h6>
<ul class="plain ">
<li><a class="lbl ">C++98-17</a>&nbsp;: we need to manually implement comparison operators</li>

<li><a class="lbl " href="tags/c++20.html">C++20</a>&nbsp;: we can tell the compiler to generate comparison operators for us</li></ul></div></div>
</header>
<section class="main plain"><h2 class="hfold " open>Principles</h2>
<div class="content " ><a class="nav " id="principles" keywords="principles value-based value-semantics equality deep"></a>
<div class="panel-fold vexpand vcompact" open><h3><span class="nav-none">C++: <em>Value</em>-Based Comparisons</span>
<span class="nav-only">Value/Identity</span></h3>
<p class="large">= objects are equal/less/&hellip; if their (member) values are equal/less/&hellip;</p></div>
<div class="panel-col "{style=""><div class="panel-row responsive"{style=""><div class="panel "><h6><strong><em>Value-Based</em></strong> =&nbsp;compares&nbsp;(member)&nbsp;values</h6>
<table class="vcompact left-justify"><tbody><tr><th>C++</th>     <td><code class="inset ">a == b</code></td></tr>
<tr><th>Java</th>    <td><code class="inset ">a.equals(b)</code></td></tr>
<tr><th>Python</th>  <td><code class="inset ">a is b</code></td></tr></tbody></table></div>
<div class="panel "><h6><strong><em>Identity-Based</em></strong> =&nbsp;compares&nbsp;memory&nbsp;addresses</h6>
<table class="vcompact left-justify"><tbody><tr><th>C++</th>    <td><code class="inset "><span class="e1">&amp;</span>a == <span class="e1">&amp;</span>b</code></td></tr>
<tr><th>Java</th>   <td><code class="inset ">a == b</code></td></tr>
<tr><th>Python</th> <td><code class="inset ">a == b</code></td></tr></tbody></table></div></div>
<div class="panel-fold vexpand vcompact" ><h5 class="nav-none">Reminder: C++ uses <em>Value Semantics</em></h5>
<p class="large">= variables refer to objects themselves, i.e., they are not just references/pointers</p></div>
<div class="panel "><p>This is the default behavior for fundamental types (<code>int</code>, <code>double</code>, etc.) 
in almost all programming languages and also the <strong>default for user-defined types in C++</strong>:</p>
<ul>
<li><strong>deep copying</strong>: copies refer to different objects; (member) <em>values</em> are copied</li>

<li><strong>deep assignment</strong>: target replicates source object's value</li>

<li><strong>deep ownership</strong>: member variables refer to objects with same lifetime as containing object</li>

<li><mark><strong><em>value-based</em> comparison</strong>: variables compare equal/less/&hellip; if their <em>values</em> are equal/less/&hellip;</mark></li></ul></div></div>
<div class="panel "><h3><span class="nav-none">Pairwise Value Relations</span>
<span class="nav-only">Relations</span></h3>
<p class="large">Two objects <code>a</code> and <code>b</code> are</p>
<table class="vtop"><tbody><tr><td class="large"><strong><em>equal</em></strong>,</td>
<td>if <code class="inset ">a&nbsp;<span class="e2">==</span>&nbsp;b</code>
is&nbsp;<i>true</i>,&emsp; (their&nbsp;values&nbsp;are&nbsp;the&nbsp;same)</td></tr>
<tr><td class="large"><strong><em>equivalent</em></strong>,</td>
<td>if <code class="inset "><strong>!</strong>(a&nbsp;<span class="e2">&lt;</span>&nbsp;b) &amp;&amp; <strong>!</strong>(b&nbsp;<span class="e2">&lt;</span>&nbsp;a)</code>
is&nbsp;<i>true</i>&emsp; (neither&nbsp;one&nbsp;is&nbsp;ordered&nbsp;before&nbsp;the&nbsp;other)</td></tr>
<tr><td class="large"><strong><em>incomparable</em></strong>,</td>
<td>if <code class="inset ">a&nbsp;&lt;&nbsp;b</code>, <code class="inset ">b&nbsp;&lt;&nbsp;a</code> and <code class="inset ">a&nbsp;==&nbsp;b</code>
are&nbsp;all&nbsp;<i>false</i>&emsp; (unordered)</td></tr></tbody></table>
<hr>
<p><strong><em>Partial</em></strong> <strong>Relation</strong>: incomparable values are allowed</p>
<p><strong><em>Total</em></strong> <strong>Relation</strong>: at least one of <code class="inset ">a&nbsp;&lt;&nbsp;b</code>, <code class="inset ">b&nbsp;&lt;&nbsp;a</code> and <code class="inset ">a&nbsp;==&nbsp;b</code> must be <i>true</i> for <em>any</em> pair of values</p></div>
<div class="panel-fold vexpand vcompact" ><h3><span class="nav-none">Comparison-Salient State</span>
<span class="nav-only">Salient State</span></h3>
<a class="nav " id="salient-state" keywords="salient-state "></a>
<p class="large">= members of a type that form its actual <em>value</em></p></div>
<div class="panel vcompact"><ul class="symbols ">
<li class="cat-yes">container items: string characters, vector elements, &hellip;</li>

<li class="cat-yes">day, month & year of a 'Date' type</li>

<li class="cat-yes">numerator & denominator of a 'Fraction' type</li>
&hellip;</ul>
<h6>Non-salient members should not take part in comparisons:</h6>
<ul class="symbols ">
<li class="cat-no">memory management details: vector capacity, buffer addresses, &hellip;</li>

<li class="cat-no">execution details: thread handles, mutexes, &hellip;</li>

<li class="cat-no">value caches: intermediate results, lookup tables, &hellip;</li>
&hellip;</ul></div>
<div class="panel-fold vexpand vcompact" ><h3>Substitutability</h3>
<a class="nav " id="substitutability" keywords="substitutability "></a>
<p><code class="inset ">a == b</code> implies <code class="inset ">f(a) == f(b)</code>,</p>
<p><code class="inset ">a &lt; b</code> implies <code class="inset ">f(a) &lt; f(b)</code>, etc.</p></div>
<div class="panel-col "{style=""><div class="panel vcompact"><p>i.e., if <code class="inset ">a</code> is equal/equivalent to <code class="inset ">b</code>,
then <code class="inset ">f(a)</code> is also equal/equivalent to <code class="inset ">f(b)</code>
as long as function <code class="inset ">f</code> reads only comparison-salient state.</p></div>
<div class="panel cs-light ">
<pre class="notranslate"><code><span class="c6 ">std::</span>string a = "123";
<span class="c6 ">std::</span>string b = "123";  <span class="comment ">// same value as a</span>
int fa = <span class="c6 ">std::</span>stoi(a);  <span class="comment ">// string &rarr; int</span>
int fb = <span class="c6 ">std::</span>stoi(b);
if (a == b) { <span class="comment ">/* then we expect fa == fb */</span> }</code></pre>
</div></div></div>
<h2 class="hfold " open><span class="hwide">Equality Comparisons</span>
<span class="hslim">Equality</span>
<span class="hnavi">Equality</span></h2>
<div class="content " ><a class="nav " id="equality-comparisons" keywords="equality-comparisons equality"></a>
<div class="panel "><h4 class="nav-none">Does '<code>a</code>' have the same value as '<code>b</code>'?</h4>
<div class="block ">
<pre class="notranslate"><code>bool <strong>operator</strong> <span class="e1">==</span> (T const&amp; a, T const&amp; b);
bool <strong>operator</strong> <span class="e1">!=</span> (T const&amp; a, T const&amp; b);</code></pre>
</div></div>
<div class="panel-fold " open><h3 class="nav-none"><span class="hwide">Example: Comparable Integer Interval</span>
<span class="hslim">Example: Integer Interval</span></h3>
<a class="nav " id="comparable-interval" keywords="comparable-interval "></a></div>
<div class="panel hvtight bg-filled "><div class="panel-fold " open><h4><span class="nav-none">Manual Definition</span>
<span class="nav-only">Manual</span>
<div class="labels "><a class="lbl ">C++98-17</a></div></h4>
<a class="nav " id="irange-example" keywords="irange-example "></a></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>class <strong>irange</strong> {
  int min_; int max_;
<span class="sfold " >public:&ensp;</span><span>  explicit constexpr
<strong>  irange</strong>(int min, int max) noexcept: <span class="hslim-br"></span><span class="hslim">    </span>min_{min}, max_{max} {
    if(min_ &gt; max_) std::swap(min_, max_);
  }
  int <strong>min</strong>() const noexcept { <span class="annotation">&hellip;</span> }
  int <strong>max</strong>() const noexcept { <span class="annotation">&hellip;</span> }</span>
  <strong>friend</strong> bool <span class="e1">operator ==</span> <span class="hslim-br"></span><span class="hslim">  </span><strong>(</strong>irange const&amp; l, irange const&amp; r<strong>)</strong> noexcept {   
    return l.min() == r.min() &amp;&amp; <span class="hslim-br"></span><span class="hslim">           </span>l.max() == r.max();
  }
  <strong>friend</strong> bool <span class="e1">operator !=</span> <span class="hslim-br"></span><span class="hslim">  </span><strong>(</strong>irange const&amp; l, irange const&amp; r<strong>)</strong> noexcept {   
    return !(l <strong>==</strong> r);  <span class="comment ">// reuse operator==</span>
  }
};</code></pre>
</div></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>int <strong>main</strong>() {
  irange r1 { 0,10};
  irange r2 {20,30};
  if(r1 <span class="e1">==</span> r2) { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>false</i></span>
  if(r1 <span class="e1">!=</span> r2) { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>true</i></span>
}</code></pre>
</div>
<div class="panel-fold " open><h4><span class="nav-none">Defaulted Definition</span>
<span class="nav-only">Defaulted</span>
<div class="labels "><a class="lbl " href="tags/c++20.html">C++20</a></div>
<a class="nav " id="defaulted-equality-comparisons" keywords="defaulted-equality-comparisons "></a></h4></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>class <strong>irange</strong> {
  int min_; int max_;
<span class="sfold " >public:&ensp;</span><span>  explicit constexpr
<strong>  irange</strong>(int min, int max) noexcept: <span class="hslim-br"></span><span class="hslim">    </span>min_{min}, max_{max} {
    if(min_ &gt; max_) std::swap(min_, max_);
  }
  int <strong>min</strong>() const noexcept { <span class="annotation">&hellip;</span> }
  int <strong>max</strong>() const noexcept { <span class="annotation">&hellip;</span> }</span>
  bool <span class="e1">operator ==</span> <span class="hslim-br"></span><span class="hslim">  </span><strong>(</strong>irange const&amp;<strong>)</strong> <span class="e2">const</span> <span class="e1"> = default</span>;
};</code></pre>
</div>
<div class="panel "><ul class="symbols ">
<li class="cat-positive">compiler generates recursive comparison of all members</li>

<li class="cat-positive">no need to define <code>operator!=</code>, 
compiler will rewrite call <code class="inset ">a != b</code> as <code class="inset ">!(a == b)</code>
if necessary</li>

<li class="cat-positive">we can just use a <em>member</em> function declaration that only takes
one right hand side parameter</li>

<li class="cat-neutral">requires that every member is <code class="inset ">==</code> comparable</li></ul></div></div></div>
<div class="panel-fold " ><h3><span class="hwide">Comparing Between Different Types</span>
<span class="hslim">Comparing Different Types</span>
<span class="hnavi">Diff.Types</span></h3>
<a class="nav " id="equality-between-types" keywords="equality-between-types "></a></div>
<div class="panel hvtight bg-filled "><div class="panel cat-guideline"><h5 class="nav-none">You should generally avoid comparing different types for equality.</h5>
<p>However, in rare cases it can be justified, e.g., when two
different types express values of the same underlying domain, e.g.,
two different integer types expressing values <em>in the same range</em>.</p></div>
<div class="panel-col "{style=""><div class="panel "><h5 class="nav-none">Goal: each type should work on both sides of operator</h5></div>
<div class="panel cs-light ">
<pre class="notranslate"><code><span class="e1">A</span> <span class="c1">a</span>;
if(<span class="c1">a</span> == <span class="c1">a</span>) { <span class="annotation">&hellip;</span> }
<span class="e2">B</span> <span class="c2">b</span>;
if(<span class="c1">a</span> == <span class="c2">b</span>) { <span class="annotation">&hellip;</span> }
if(<span class="c2">b</span> == <span class="c1">a</span>) { <span class="annotation">&hellip;</span> }</code></pre>
</div></div>
<div class="panel-fold vexpand" open><h5><span class="nav-none"><a class="lbl ">C++98-17</a>&ensp; one operator function for each combination needed<span class="if-opened">:</span></span>
<span class="nav-only">C++17</span></h5></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>class <span class="e2">B</span> { <span class="annotation">&hellip;</span> };
class <span class="e1">A</span> { public: <span class="annotation">&hellip;</span>
  <span class="comment ">// symmetric</span>
  friend bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a1, <span class="e1">A</span> const&amp; a2) noexcept { <span class="annotation">&hellip;</span> }
  <span class="comment ">// asymmetric</span>
  friend bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a, <span class="e2">B</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  friend bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e2">B</span> const&amp; a, <span class="e1">A</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  <span class="annotation">&hellip;</span>
};</code></pre>
</div>
<div class="panel-fold vexpand" open><h5><span class="nav-none"><a class="lbl " href="tags/c++20.html">C++20</a>&ensp; only one operator (member) function per type pair needed<span class="if-opened">:</span></span>
<span class="nav-only">C++20</span></h5></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>class <span class="e2">B</span> { <span class="annotation">&hellip;</span> };
class <span class="e1">A</span> { public: <span class="annotation">&hellip;</span>
  <span class="comment ">// symmetric</span>
  bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a) <strong>const</strong> noexcept { <span class="annotation">&hellip;</span> }  <span class="comment hwide">// or = default;</span>
  <span class="comment ">// asymmetric - either one member:</span>
  bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e2">B</span> const&amp; b) <strong>const</strong> noexcept { <span class="annotation">&hellip;</span> }
  <span class="comment ">// or one free-standing function:</span>
  friend bool <strong>operator ==</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a, <span class="e2">B</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  <span class="annotation">&hellip;</span>
};</code></pre>
</div>
<div class="panel "><p>compiler rewrites a call <code class="inset ">a == b</code> as <code class="inset ">b == a</code> if necessary</p></div></div></div>
<div class="panel-fold " open><h3 class="cat-guideline"><span class="nav-none">Implementing <code>operator==</code> / <code>!=</code></span>
<span class="nav-only">Guidelines</span></h3>
<a class="nav " id="implementing-equality" keywords="implementing-equality "></a></div>
<div class="panel hvtight bg-filled "><div class="panel-fold bullet " ><h5 class="nav-none">Only, if your type has a clearly defined <q>value</q></h5></div>
<div class="panel "><div class="grid-gallery-L "><div class="content " ><h6><span class="sym-good"></span> like, e.g.,</h6>
<ul class="symbols ">
<li class="cat-yes">math numbers: integer, complex, dual, quaternion, &hellip;</li>

<li class="cat-yes">container elements: vector items, string characters, &hellip;</li>

<li class="cat-yes">physical quantities: mass, distance, &hellip;</li>

<li class="cat-yes">geometric entities: point, rotation, direction, &hellip;</li>

<li class="cat-yes">settings/configuration storage</li></ul></div>
<div class="content " ><h6><span class="sym-bad"></span> no value:</h6>
<ul class="symbols ">
<li class="cat-no">input/output stream</li>

<li class="cat-no">execution primitives: thread, mutex, lock, &hellip;</li></ul></div></div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Only, if it models true equality</h5></div>
<div class="panel-col "{style=""><div class="panel "><ul>
<li><em>Reflexivity</em>: <code class="inset ">a == a</code> must be <i>true</i></li>

<li><em>Symmetry</em>: results of <code class="inset ">a == b</code> and <code class="inset ">b == a</code> must be the same</li>

<li><em>Transitivity</em>: if <code class="inset ">a == b</code> and <code class="inset ">b == c</code> are both <i>true</i> then <code class="inset ">a == c</code> must be <i>true</i></li></ul>
<h6 class="nav-none cat-guideline">Do not ignore part of an object's salient state in <code>operator==</code>:</h6>
<ul class="symbols vcompact">
<li class="cat-no">case-insensitive string comparison (ignores letter case)</li>

<li class="cat-no">order of magnitude float comparison (ignores mantissa)</li>

<li class="cat-no">punctuation-ignoring text comparison</li></ul>
<h6 class="nav-none cat-guideline">Provide weaker comparisons as descriptively named comparison functions:</h6>
<ul class="symbols vcompact">
<li class="cat-yes"><code>compare_case_insensitive</code></li>

<li class="cat-yes"><code>same_order_of_magnitude</code></li>

<li class="cat-yes"><code>same_excluding_punctuation</code></li></ul></div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Compare the members that form the actual value</h5></div>
<div class="panel "><ul class="symbols vcompact">
<li class="cat-yes">container items: string characters, vector elements, &hellip;</li>

<li class="cat-yes">day, month &amp; year of a 'Date' type</li>

<li class="cat-yes">numerator &amp; denominator of a 'Fraction' type</li></ul>
<h6 class="nav-none">Non-salient members should not take part in comparisons:</h6>
<ul class="symbols vcompact">
<li class="cat-no">memory management details: vector capacity, buffer addresses, &hellip;</li>

<li class="cat-no">execution details: thread handles, mutexes, &hellip;</li>

<li class="cat-no">value caches: intermediate results, lookup tables, &hellip;</li></ul>
<hr>
<h6 class="nav-none cat-important">Copies must always compare equal:</h6>
<div class="panel cs-light border">
<pre class="notranslate"><code><span class="c6 ">std::</span>string a = "xyz";
<span class="c6 ">std::</span>string b = a;  <span class="comment ">// copy of a</span>
if (a <span class="e1">==</span> b) { <span class="comment ">/* then OK */</span> }</code></pre>
</div>
<hr>
<h6 class="nav-none cat-important">Salient member changed to different value 
&rArr; object must no longer compare equal to its previous state:</h6>
<div class="panel cs-light border">
<pre class="notranslate"><code><span class="c6 ">std::</span>string a = "xyz";
<span class="c6 ">std::</span>string b = "xyz";  <span class="comment ">// same value as a</span>
a[1] = "W";  <span class="comment ">// <strong>&lt;-- </strong></span>
if (a <span class="e1">!=</span> b) { <span class="comment ">/* then OK */</span> }</code></pre>
</div>
<hr>
<h6 class="nav-none cat-guideline">Equality should imply substitutability</h6>
<p>If <code class="inset ">a</code> is equal to <code class="inset ">b</code>,
then <code class="inset ">f(a)</code> should also be equal to <code class="inset ">f(b)</code>
as long as function <code class="inset ">f</code> reads only comparison-salient state.</p>
<div class="panel cs-light border">
<pre class="notranslate"><code><span class="c6 ">std::</span>string a = "123";
<span class="c6 ">std::</span>string b = "123";  <span class="comment ">// same value as a</span>
int fa = <span class="c6 ">std::</span>stoi(a);  <span class="comment ">// string &rarr; int</span>
int fb = <span class="c6 ">std::</span>stoi(b);
if (a == b) { <span class="comment ">/* then we expect fa == fb */</span> }</code></pre>
</div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Start comparison with members that are most likely to differ</h5></div>
<div class="panel-col "{style=""><div class="panel vcompact"><h6 class="nav-none">Employ logic operator short-circuiting or early returns</h6>
<ul>
<li>compare size (= number of elements) of a container (vector,string,map,set,&hellip;) 
before comparing all individual elements</li>

<li>compare house numbers and streets before comparing cities of addresses</li>

<li>compare first names of persons before comparing last names</li>

<li>could use cheap hash comparison (e.g. using a bloom filter) 
before comparing all data</li></ul></div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Also provide <span class="hwide"> a matching</span> <code>operator<strong>!=</strong></code>
<div class="labels "><a class="lbl ">C++98-17</a></div></h5></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code><span class="comment ">// implement it in terms of operator==</span>
friend bool <span class="e1">operator !=</span> <span class="hslim-br"></span><span class="hslim">  </span>(A const&amp; l, A const&amp; r) { 
  return <span class="e1">!</span>(l <span class="e2">==</span> r);
}</code></pre>
</div>
<div class="panel "><p><a class="lbl " href="tags/c++20.html">C++20</a> only needs <code class="inset ">operator ==</code>
because compiler rewrites call <code class="inset ">a != b</code> as <code class="inset ">!(a == b)</code></p></div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Make <code>operator==</code> <em>noexcept</em></h5></div>
<div class="panel vcompact"><h6 class="nav-none">Comparison operations should never encounter exceptional situations:</h6>
<ul>
<li><p>Comparisons must always be <em>read-only</em> operations</p>
<ul class="cbullets "><li class="follows ">no out-of-memory errors</li>
<li class="follows ">no file access errors</li>
&hellip;</ul></li>

<li><p>No problem, if (part) of a value is not available 
(e.g., internal memory buffer not yet allocated, file not opened, &hellip;)</p>
<ul>
<li>both values not available &rArr; equal</li>

<li>one value available, one not available &rArr; not equal</li>

<li>both values available &rArr; compare values</li></ul></li></ul></div></div></div>
<h2 class="hfold " open><span class="hwide">Ordering Comparisons</span>
<span class="hslim">Ordering</span>
<span class="hnavi">Ordering</span></h2>
<div class="content " ><a class="nav " id="ordering-comparisons" keywords="ordering-comparisons order ordering"></a>
<div class="panel "><h4 class="nav-none">Does '<code>a</code>' go before or after '<code>b</code>'?</h4>
<div class="block ">
<pre class="notranslate"><code>bool <strong>operator</strong> <span class="e1">&lt; </span> (T const&amp; a, T const&amp; b);
bool <strong>operator</strong> <span class="e1">&lt;=</span> (T const&amp; a, T const&amp; b);
bool <strong>operator</strong> <span class="e1">&gt; </span> (T const&amp; a, T const&amp; b);
bool <strong>operator</strong> <span class="e1">&gt;=</span> (T const&amp; a, T const&amp; b);</code></pre>
</div></div>
<div class="panel-fold " open><h3><span class="hwide">Example: Comparable Date</span>
<span class="hslim">Example: Date</span>
<span class="hnavi">Example</span></h3></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>enum class <strong>month</strong> { jan = 1, <span class="hwide">feb = 2, </span><span class="annotation">&hellip;</span>, dec = 12 };
<span class="spacer"></span>struct <strong>date {</strong>
  int yyyy;   month mm;   int dd; 
<span class="spacer"></span>  <strong>friend</strong> bool <span class="e1">operator &lt;</span> <span class="hslim-br"></span><span class="hslim">  </span><strong>(</strong>date <span class="e2">const&amp;</span> l, date <span class="e2">const&amp;</span> r<strong>)</strong> noexcept {
    if(l.yyyy &lt; r.yyyy) return true;
    if(l.yyyy &gt; r.yyyy) return false;
    if(l.mm &lt; r.mm) return true;
    if(l.mm &gt; r.mm) return false;
    if(l.dd &lt; r.dd) return true;
    return false;
  }
  <span class="comment ">// more ordering operators </span>
  friend bool <strong>operator</strong> <span class="e1">&lt;=</span> ( <span class="annotation">&hellip;</span> ) { <span class="annotation">&hellip;</span> }
  friend bool <strong>operator</strong> <span class="e1">&gt;</span>  ( <span class="annotation">&hellip;</span> ) { <span class="annotation">&hellip;</span> }
  friend bool <strong>operator</strong> <span class="e1">&gt;=</span> ( <span class="annotation">&hellip;</span> ) { <span class="annotation">&hellip;</span> }
  <span class="comment ">// equality comparison operators </span>
  friend bool <strong>operator</strong> <span class="e1">==</span> ( <span class="annotation">&hellip;</span> ) { <span class="annotation">&hellip;</span> }
  friend bool <strong>operator</strong> <span class="e1">!=</span> ( <span class="annotation">&hellip;</span> ) { <span class="annotation">&hellip;</span> }
<strong>};</strong>
<hr>int <strong>main</strong>() {
  date earlier {2017, month::dec, 24};
  date later   {2018, month::may, 12};
  if(earlier <span class="e1">&lt;</span> later) { <span class="annotation">&hellip;</span> };  <span class="comment ">// <i>true</i></span>
}</code></pre>
</div></div>
<div class="panel-fold " ><h3><span class="hwide">Comparing Between Different Types</span>
<span class="hslim">Comparing Different Types</span>
<span class="hnavi">Diff.Types</span></h3>
<a class="nav " id="ordering-between-types" keywords="ordering-between-types "></a></div>
<div class="panel hvtight bg-filled "><div class="panel cat-guideline"><h5 class="nav-none">You should generally avoid comparisons between different types.</h5>
<p>However, in rare cases it can be justified, e.g., when two
different types express values of the same underlying domain, e.g.,
two different integer types expressing values <em>in the same range</em>.</p></div>
<div class="panel-col "{style=""><div class="panel "><h5 class="nav-none">Goal: each type should work on both sides of operator</h5></div>
<div class="panel cs-light ">
<pre class="notranslate"><code><span class="e1">A</span> <span class="c1">a</span>;
if(<span class="c1">a</span> &lt; <span class="c1">a</span>) { <span class="annotation">&hellip;</span> }
<span class="e2">B</span> <span class="c2">b</span>;
if(<span class="c1">a</span> &lt; <span class="c2">b</span>) { <span class="annotation">&hellip;</span> }
if(<span class="c2">b</span> &lt; <span class="c1">a</span>) { <span class="annotation">&hellip;</span> }</code></pre>
</div></div>
<div class="panel-fold vexpand" open><h5><span class="nav-none"><a class="lbl ">C++98-17</a>&ensp; one operator function for each combination needed<span class="if-opened">:</span></span>
<span class="nav-only">C++17</span></h5></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>class <span class="e2">B</span> { <span class="annotation">&hellip;</span> };
class <span class="e1">A</span> { public: <span class="annotation">&hellip;</span>
  <span class="comment ">// symmetric</span>
  friend bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a1, <span class="e1">A</span> const&amp; a2) noexcept { <span class="annotation">&hellip;</span> }
  <span class="comment ">// asymmetric</span>
  friend bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a, <span class="e2">B</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  friend bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e2">B</span> const&amp; a, <span class="e1">A</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  <span class="annotation">&hellip;</span>
};</code></pre>
</div>
<div class="panel-fold vexpand" open><h5><span class="nav-none"><a class="lbl " href="tags/c++20.html">C++20</a>&ensp; only one operator (member) function per type pair needed<span class="if-opened">:</span></span>
<span class="nav-only">C++20</span></h5></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>class <span class="e2">B</span> { <span class="annotation">&hellip;</span> };
class <span class="e1">A</span> { public: <span class="annotation">&hellip;</span>
  <span class="comment ">// symmetric</span>
  bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a) <strong>const</strong> noexcept { <span class="annotation">&hellip;</span> }  <span class="comment hwide">// or = default;</span>
  <span class="comment ">// asymmetric - either one member:</span>
  bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e2">B</span> const&amp; b) <strong>const</strong> noexcept { <span class="annotation">&hellip;</span> }
  <span class="comment ">// or one free-standing function:</span>
  friend bool <strong>operator &lt;</strong> <span class="hslim-br"></span><span class="hslim">  </span>(<span class="e1">A</span> const&amp; a, <span class="e2">B</span> const&amp; b) noexcept { <span class="annotation">&hellip;</span> }
  <span class="annotation">&hellip;</span>
};</code></pre>
</div>
<div class="panel "><p>compiler rewrites a call <code class="inset ">a &lt; b</code> as <code class="inset ">b &lt; a</code> if necessary</p></div>
<div class="panel cat-guideline"><p>Prefer to implement just C++20's <code class="inset ">operator &lt;=&gt;</code> instead of
individual ordering operators.</p></div></div></div>
<div class="panel-fold " open><h3 class="cat-guideline"><span class="hwide">Implementing Ordering Operators</span>
<span class="hslim">Ordering Operators?</span>
<span class="hnavi">Guidelines</span></h3>
<a class="nav " id="implementing-ordering" keywords="implementing-ordering "></a></div>
<div class="panel hvtight bg-filled "><div class="panel "><h5 class="nav-none"><a class="lbl " href="tags/c++20.html">C++20</a>&ensp; Prefer <code>operator&lt;=&gt;</code> and use comparison categories!
(see&nbsp;<a class="" href="cpp/lang/comparisons.html#three-way-comparisons" onclick="reveal_anchor()">

next&nbsp;section
</a>).</h5></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Only if their meaning is clear and unambiguous!</h5></div>
<div class="panel "><h6>Example: We should not provide an ordering for a type that models
an <q>interval</q> (like <a class="" href="cpp/lang/comparisons.html#irange-example" onclick="reveal_anchor()">

<code>irange</code>
</a>)!</h6>
<p>What could it mean that interval A is <q>less than</q>, i.e., should be
ordered before interval B?</p>
<ul>
<li>only the left bound of A could be smaller than the left bound of B,</li>

<li>both bounds of A could be smaller than the left bound of B,</li>

<li>or A could have a smaller width (max-min) than B.</li></ul>
<ul class="cbullets "><li class="follows ">ambiguous interface<br></li>
<li class="follows ">code that uses such an ordering would be confusing and error-prone<br></li></ul></div><div class="panel-fold bullet " ><h5 class="nav-none">Don't provide an ordering just because a (standard) algorithm requires one!</h5></div>
<div class="panel-col "{style=""><div class="panel title vcompact minor"><h6 class="nav-none cat-guideline">Pass a custom comparator (as lambda or function) instead!</h6></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>struct <strong>Box</strong> {
  int id; 
  double weight;
  Location origin;
  Location target;
};
<span class="spacer"></span>auto <strong>heaviest</strong>(<span class="c6 ">std::</span>vector&lt;Box&gt; const&amp; v) {
  return max_element<strong>(</strong>begin(v), end(v), 
    <span class="e2">[](</span>Box const&amp; a, Box const&amp; b<span class="e2">){</span> <span class="hslim-br"></span><span class="hslim">        </span>return a.weight &lt; b.weight; <span class="hslim-br"></span><span class="hslim">    </span><span class="e2">}</span><strong>)</strong>;
}</code></pre>
</div></div><div class="panel-fold bullet " ><h5 class="nav-none">You should either provide all or none of the 4 ordering operators</h5></div>
<div class="panel vcompact"><p>Everyone &ndash; including yourself &ndash; expects that if
<code class="inset ">a &lt; b</code> compiles, then <code class="inset ">b &gt; a</code> does also compile.</p>
<p>Incomplete implementation of ordering operators will almost
certainly lead to countless situations where you or users of your
type have to waste time on diagnosing compiler errors.</p>
<p>Providing only strict comparisons <code class="inset ">&lt;</code> and <code class="inset ">&gt;</code> but not
<code class="inset ">&lt;=</code> and <code class="inset ">&gt;=</code> can be justified in very rare situations, 
but only if you don't provide <code class="inset ">==</code> and <code class="inset ">!=</code> as well.</p></div>
<div class="panel-fold bullet " ><h5 class="nav-none">If you provide ordering operators you should also provide 
equality comparison with <code>==</code> and <code>!=</code></h5></div>
<div class="panel "><ul>
<li>if <code class="inset ">a &lt;= b</code> compiles, then <code class="inset ">a &lt; b || a == b</code> should also compile</li>

<li>if <code class="inset ">a &gt;= b</code> compiles, then <code class="inset ">a &gt; b || a == b</code> should also compile</li></ul></div>
<div class="panel-fold bullet " ><h5 class="nav-none">The equality induced by <code>&lt;=</code> and <code>&gt;=</code>
should be identical to that of <code>==</code></h5></div>
<div class="panel "><ul>
<li><code class="inset ">a &lt;= b</code> and <code class="inset ">a &lt; b || a == b</code> should give the same answer</li>

<li><code class="inset ">a &gt;= b</code> and <code class="inset ">a &gt; b || a == b</code> should give the same answer</li></ul></div><div class="panel-fold bullet " ><h5 class="nav-none">Make comparison operators <em>noexcept</em></h5></div>
<div class="panel vcompact"><h6 class="nav-none">Comparison operations should never encounter exceptional situations:</h6>
<ul>
<li><p>Comparisons must always be <em>read-only</em> operations</p>
<ul class="cbullets "><li class="follows ">no out-of-memory errors</li>
<li class="follows ">no file access errors</li>
&hellip;</ul></li>

<li><p>No problem, if (part) of a value is not available 
(e.g., internal memory buffer not yet allocated, file not opened, &hellip;)</p>
<ul>
<li>both values not available &rArr; equal</li>

<li>one value available, one not available &rArr; not equal</li>

<li>both values available &rArr; compare values</li></ul></li></ul></div></div></div>
<h2 class="hfold " open><span class="hwide">3-Way Comparisons &ensp;<a class="lbl " href="tags/c++20.html">C++20</a></span>
<span class="hslim">3-Way &ensp;<a class="lbl " href="tags/c++20.html">C++20</a></span>
<span class="hnavi">3-Way <a class="lbl " href="tags/c++20.html">C++20</a></span></h2>
<div class="content " ><a class="nav " id="three-way-comparisons" keywords="three-way-comparisons 3-way three-way"></a>
<div class="panel-fold " open><h3><span class="nav-none"><q>Spaceship</q> Operator <code><strong>&lt;=&gt;</strong></code> <div class="labels hwide"><a class="lbl " href="tags/c++20.html">C++20</a></div></span>
<span class="nav-only">operator&lt;=&gt;</span></h3></div>
<div class="panel hvtight bg-filled "><div class="panel-fold vexpand" open><h4 class="nav-none">Determines the relative ordering of 2 objects<span class="if-opened">:</span></h4></div>
<div class="panel vcompact"><table class="left-justify"><tbody><tr><td><code>(a <span class="e1">&lt;=&gt;</span> b) &lt;  0</code></td>
<td>if a &lt; b</td></tr>
<tr><td><code>(a <span class="e1">&lt;=&gt;</span> b) &gt;  0</code></td>
<td>if a &gt; b</td></tr>
<tr><td><code>(a <span class="e1">&lt;=&gt;</span> b) == 0</code></td>
<td>if a and b are equal/equivalent</td></tr></tbody></table>
<h6 class="nav-none">The return value comes from one of three comparison categories:</h6>
<table class="vcompact"><thead><tr><th>category</th>  <th>equivalent values</th>  <th>incomparable values</th></tr></thead>
<tbody><tr><td><code><span class="hwide"><span class="c6 ">std::</span></span>strong_ordering</code></td>
<td>are indistinguishable <span class="hwide">(truly equal)</span></td>
<td>forbidden</td></tr>
<tr><td><code><span class="hwide"><span class="c6 ">std::</span></span>weak_ordering</code></td>
<td>can be distiguished</td>
<td>forbidden</td></tr>
<tr><td><code><span class="hwide"><span class="c6 ">std::</span></span>partial_ordering</code></td>
<td>can be distiguished</td>
<td>allowed</td></tr></tbody></table></div>
<div class="panel-fold vexpand no-spacing" open><h4 class="nav-none"><code>operator&lt;=&gt;</code> is predefined for<span class="if-opened">:</span> <span class="if-closed">&hellip;</span></h4></div>
<div class="panel "><ul>
<li><h6 class="nav-none">Integers (<code>char</code>, <code>int</code>, &hellip;) and <code>bool</code></h6>
<p><code>4&nbsp;&lt;=&gt;&nbsp;6</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>less</em></code><br>
<code>5&nbsp;&lt;=&gt;&nbsp;5</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>equal</em></code><br>
<code>8&nbsp;&lt;=&gt;&nbsp;1</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>greater</em></code></p></li>

<li><h6 class="nav-none">Floating-Point Types</h6>
<p>are partially ordered, because of incomparable "Not A Number" values
for representing division-by-zero, overflow, etc.
(e.g., IEEE&nbsp;754 silent+signalling NaNs)</p>
<p><code>4.1&nbsp;&lt;=&gt;&nbsp;6.3</code>&ensp;&rarr;&nbsp;&nbsp;<code>partial_ordering::<em>less</em></code><br>
<code>5.2&nbsp;&lt;=&gt;&nbsp;5.2</code>&ensp;&rarr;&nbsp;&nbsp;<code>partial_ordering::<em>equivalent</em></code><br>
<code>8.3&nbsp;&lt;=&gt;&nbsp;1.4</code>&ensp;&rarr;&nbsp;&nbsp;<code>partial_ordering::<em>greater</em></code></p></li>

<li><h6 class="nav-none">Orderable standard types (<code>vector</code>, <code>string</code>, &hellip;)</h6>
<p><code>"ab"s&nbsp;&lt;=&gt;&nbsp;"bc"s</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>less</em></code><br>
<code>"ab"s&nbsp;&lt;=&gt;&nbsp;"ab"s</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>equal</em></code><br>
<code>"bc"s&nbsp;&lt;=&gt;&nbsp;"ab"s</code>&ensp;&rarr;&nbsp;&nbsp;<code>strong_ordering::<em>greater</em></code></p></li></ul></div>
<div class="panel-fold vexpand no-spacing" open><h4 class="nav-none">Providing only <code>&lt;=&gt;</code> makes 
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> work, too!</h4></div>
<div class="panel "><p>If one of the boolean comparison operators 
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> or <code>&gt;=</code> is not found,
the compiler will rewrite the call expression in terms of <code>&lt;=&gt;</code>
if necessary:</p>
<ul class="plain vcompact">
<li><code class="inset ">a == b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) == 0</code></li>

<li><code class="inset ">a != b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) != 0</code></li>

<li><code class="inset ">a &lt;  b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) &lt;  0</code></li>

<li><code class="inset ">a &gt;  b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) &gt;  0</code></li>

<li><code class="inset ">a &lt;= b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) &lt;= 0</code></li>

<li><code class="inset ">a &gt;= b</code> can be rewritten as <code class="inset ">(a &lt;=&gt; b) &gt;= 0</code></li></ul>
<p class="large">&rArr; in C++20 we only need to provide either only <code>operator==</code>
for equality-comparable types without an ordering 
or only <code>operator&lt;=&gt;</code> for orderable types</p></div></div>
<div class="panel-fold " open><h3 class="nav-none">Implementing <code>operator<strong>&lt;=&gt;</strong></code> <div class="labels hwide"><a class="lbl " href="tags/c++20.html">C++20</a></div></h3></div>
<div class="panel hvtight bg-filled "><div class="panel-fold " open><h4><span class="nav-none">Defaulted Definition</span>
<span class="nav-only">Defaulted &lt;=&gt;</span></h4></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code><span class="c6">#include &lt;compare&gt;</span>
<span class="spacer"></span>enum class <strong>month</strong> { jan = 1, <span class="hwide">feb = 2, </span><span class="annotation">&hellip;</span>, dec = 12 };
<span class="spacer"></span>struct <strong>date</strong> {
  int yyyy;   month mm;   int dd; 
  <span class="e2">auto</span> <span class="e1">operator &lt;=&gt;</span> (date const&amp;) <span class="e2">const</span> <span class="e1">&nbsp;&nbsp;=&nbsp;default</span>;
}</code></pre>
</div>
<div class="panel "><p>The default operator <code>&lt;=&gt;</code> recursively compares 
all data members in order of declaration.</p></div></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>int <strong>main</strong>() {
  date earlier {2017, month::dec, 24};
  date later   {2018, month::may, 12};
<span class="spacer"></span>  if(earlier <span class="e1">&lt;</span> later) { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>true</i></span>
  if(earlier <span class="e1">&gt;</span> later) { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>false</i></span>
<span class="spacer"></span>  auto cmp = (earlier <span class="e1">&lt;=&gt;</span> later); 
  if(cmp &lt; 0)  { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>true</i></span>
  if(cmp == 0) { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>false</i></span>
  if(cmp &gt; 0)  { <span class="annotation">&hellip;</span> }  <span class="comment ">// <i>false</i></span>
}</code></pre>
</div>
<div class="panel-fold " open><h4><span class="nav-none">Manual Definition</span>
<span class="nav-only">Manual &lt;=&gt;</span></h4></div>
<div class="panel cs-light ">
<pre class="notranslate"><code><span class="c6">#include &lt;compare&gt;</span>
<span class="spacer"></span>enum class <strong>month</strong> { jan = 1, <span class="hwide">feb = 2, </span><span class="annotation">&hellip;</span>, dec = 12 };
<span class="spacer"></span>struct <strong>date</strong> {
  int yyyy;   month mm;   int dd; 
<span class="spacer"></span>  <span class="e2">auto</span> <span class="e1">operator &lt;=&gt;</span> <strong>(date const&amp; o)</strong> <span class="hslim-br"></span><span class="hslim">  </span><span class="e2">const noexcept</span> <strong>{</strong>
    <span class="comment ">// use built-in &lt;=&gt;; for ints &amp; enums</span>
    if(auto cmp = yyyy <span class="e1">&lt;=&gt;</span> o.yyyy; <span class="hslim-br"></span><span class="hslim">       </span>cmp != 0) { return cmp; }
    if(auto cmp = mm   <span class="e1">&lt;=&gt;</span> o.mm;   <span class="hslim-br"></span><span class="hslim">       </span>cmp != 0) { return cmp; }
    return dd <span class="e1">&lt;=&gt;</span> o.dd;
  <strong>}</strong>
};</code></pre>
</div></div>
<div class="panel-fold " open><h3><span class="hwide">Comparison Categories</span>
<span class="hslim">Comparison Categories</span>
<span class="hnavi">Category</span>
<div class="labels hwide"><a class="lbl " href="tags/c++20.html">C++20</a></div></h3>
<a class="nav " id="comparison-categories" keywords="comparison-categories comparison category ordering weak strong total partial"></a></div>
<div class="panel hvtight bg-filled "><div class="panel vcompact"><table class="left-justify"><thead><tr><th>Category</th>         <th></th>         <th>Possible Values</th></tr></thead>
<tbody><tr><td><h6 class="nav-none"><code>strong_ordering</code></h6></td>  <td><code>::</code></td> <td><code><em>less, greater, equivalent, equal</em></code></td></tr>
<tr><td><h6 class="nav-none"><code>weak_ordering</code></h6></td>    <td><code>::</code></td> <td><code><em>less, greater, equivalent</em></code></td></tr>
<tr><td><h6 class="nav-none"><code>partial_ordering</code></h6></td> <td><code>::</code></td> <td><code><em>less, greater, equivalent, unordered</em></code></td></tr></tbody></table>
<hr>
<table class="left-justify"><tbody><tr><td><code><strong><em>less      </em></strong></code></td> <td><code>a</code> before <code>b</code></td></tr>
<tr><td><code><strong><em>greater   </em></strong></code> <td><code>a</code> after <code>b</code></td></td></tr>
<tr><td><code><strong><em>equivalent</em></strong></code></td> <td><code>a</code> neither before nor after <code>b</code></td></tr>
<tr><td><code><strong><em>equal     </em></strong></code></td> <td><code>a</code> is the same as <code>b</code></td></tr>
<tr><td><code><strong><em>unordered </em></strong></code></td> <td><code>a</code> not comparable with <code>b</code></td></tr></tbody></table></div>
<div class="panel-fold vexpand vcompact" open><h4><span class="nav-none"><code><span class="c6 ">std::</span>strong_ordering</code></span>
<span class="nav-only">Strong</span></h4>
<p>Values: <code><em>less</em></code>, <code><em>greater</em></code>, <code><em>equal</em></code>, <code><em>equivalent</em></code> <small>(same as equal)</small></p>
<ul>
<li>equivalent values are indistinguishable (they are truly equal)</li>

<li>all values must be comparable</li></ul></div>
<div class="panel-col "{style=""><div class="panel cs-light ">
<pre class="notranslate"><code>class <strong>A</strong> {
  M m_;
public: <span class="annotation">&hellip;</span>
  <span class="c6 ">std::</span><span class="e2">strong_ordering</span>
  <strong>operator &lt;=&gt;</strong> (A const&amp; rhs) const noexcept { 
    if(m_ == rhs.m_) <span class="hslim-br"></span><span class="hslim">      </span>return <span class="c2">strong_ordering::<strong><em>equal</em></strong></span>;
    if(m_ &lt;  rhs.m_) <span class="hslim-br"></span><span class="hslim">      </span>return <span class="c2">strong_ordering::<strong><em>less</em></strong></span>;
    return <span class="c2">strong_ordering::<strong><em>greater</em></strong></span>;
  }
};</code></pre>
</div></div>
<div class="panel-fold vexpand vcompact no-spacing" ><h4><span class="nav-none"><code><span class="c6 ">std::</span>weak_ordering</code></span>
<span class="nav-only">Weak</span></h4>
<p>Values: <code><em>less</em></code>, <code><em>greater</em></code>, <code><em>equivalent</em></code></p>
<ul>
<li>can distinguish equivalent values</li>

<li>all values must be comparable</li></ul></div>
<div class="panel "><h6 class="nav-none">Examples</h6>
<ul>
<li>case-insensitive string comparison
('aBc' and 'ABC' are equivalent, but can be distinguished)</li>

<li>order of magnitude float comparison
(30 and 50 are equivalent, but can be distinguished)</li></ul>
<div class="panel cs-light border">
<pre class="notranslate"><code><span class="c6 ">std::</span><span class="e2">weak_ordering</span> <strong>compare_case_insensitive</strong> (<span class="c6 ">std::</span>string&nbsp;const&amp;,&nbsp;<span class="c6 ">std::</span>string&nbsp;const&amp;) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}
<hr><span class="c6 ">std::</span><span class="e2">weak_ordering</span> <strong>compare_order_of_magnitude</strong> (float,&nbsp;float) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}</code></pre>
</div></div>
<div class="panel-fold vexpand vcompact no-spacing" ><h4><span class="nav-none"><code><span class="c6 ">std::</span>partial_ordering</code></span>
<span class="nav-only">Partial</span></h4>
<p>Values: <code><em>less</em></code>, <code><em>greater</em></code>, <code><em>equivalent</em></code>, <code><em>unordered</em></code></p>
<ul>
<li>can distinguish equivalent values</li>

<li>incomparable values are allowed</li></ul></div>
<div class="panel "><h6 class="nav-none">Examples</h6>
<ul>
<li>number types with an incomparable "Not A Number" value
(for representing division-by-zero, overflow, etc.), 
e.g., IEEE&nbsp;754 NaNs (may be used for <code>float</code>, <code>double</code>, <code>long double</code>)</li>

<li>tree node adjacency:
child <q>less</q> than parent,
parent <q>greater</q> than child,
equivalent = same node,
unordered = nodes not adjacent</li></ul>
<div class="panel cs-light border">
<pre class="notranslate"><code><span class="c6 ">std::</span><span class="e2">partial_ordering</span> <strong>compare_adjacency</strong> (TreeNode&nbsp;const&amp;,&nbsp;TreeNode&nbsp;const&amp;) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}</code></pre>
</div></div></div>
<div class="panel-fold " open><h3 class="cat-guideline"><span class="nav-none">Implementing Orderings</span>
<span class="nav-only">Guidelines</span>
<div class="labels nav-none"><a class="lbl " href="tags/c++20.html">C++20</a></div></h3></div>
<div class="panel hvtight bg-filled "><div class="panel-fold bullet " ><h5 class="nav-none">Only if their meaning is clear and unambiguous!</h5></div>
<div class="panel "><h6>Example: We should not provide an ordering for a type that models
an <q>interval</q> (like <a class="" href="cpp/lang/comparisons.html#irange-example" onclick="reveal_anchor()">

<code>irange</code>
</a>)!</h6>
<p>What could it mean that interval A is <q>less than</q>, i.e., should be
ordered before interval B?</p>
<ul>
<li>only the left bound of A could be smaller than the left bound of B,</li>

<li>both bounds of A could be smaller than the left bound of B,</li>

<li>or A could have a smaller width (max-min) than B.</li></ul>
<ul class="cbullets "><li class="follows ">ambiguous interface<br></li>
<li class="follows ">code that uses such an ordering would be confusing and error-prone<br></li></ul></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Don't provide an ordering just because a (standard) algorithm requires one!</h5></div>
<div class="panel-col "{style=""><div class="panel title vcompact minor"><h6 class="nav-none cat-guideline">Pass a custom comparator (as lambda or function) instead!</h6></div>
<div class="panel cs-light ">
<pre class="notranslate"><code>struct <strong>Box</strong> {
  int id; 
  double weight;
  Location origin;
  Location target;
};
<span class="spacer"></span>auto <strong>heaviest</strong>(<span class="c6 ">std::</span>vector&lt;Box&gt; const&amp; v) {
  return max_element<strong>(</strong>begin(v), end(v), 
    <span class="e2">[](</span>Box const&amp; a, Box const&amp; b<span class="e2">){</span> <span class="hslim-br"></span><span class="hslim">        </span>return a.weight &lt; b.weight; <span class="hslim-br"></span><span class="hslim">    </span><span class="e2">}</span><strong>)</strong>;
}</code></pre>
</div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Avoid weak and partial orderings as result of operator&lt;=&gt;</h5></div>
<div class="panel-col "{style=""><div class="panel title vcompact minor"><h6 class="nav-none">Use a named comparison function instead:</h6></div>
<div class="panel cs-light ">
<pre class="notranslate"><code><span class="c6 ">std::</span>weak_ordering <span class="e2">compare_case_insensitive</span> (<span class="c6 ">std::</span>string&nbsp;const&amp;,&nbsp;<span class="c6 ">std::</span>string&nbsp;const&amp;) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}
<hr><span class="c6 ">std::</span>weak_ordering <span class="e2">compare_order_of_magnitude</span> (float,&nbsp;float) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}
<hr><span class="c6 ">std::</span>partial_ordering <span class="e2">compare_adjacency</span> (TreeNode&nbsp;const&amp;,&nbsp;TreeNode&nbsp;const&amp;) noexcept {&nbsp;<span class="annotation">&hellip;</span>&nbsp;}</code></pre>
</div></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Prefer to provide only <code>operator==</code> or <code>operator&lt;=&gt;</code>
instead of implementing 
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>
individually</h5></div>
<div class="panel vcompact"><p>This avoids duplicated code that could diverge when someone 
forgets to change all operators at the same time.</p>
<p>Subtle runtime bugs caused by e.g., a forgotten member comparison in 
only one operator but not in the others will be hard to diagnose!</p></div>
<div class="panel-fold bullet " ><h5 class="nav-none">The equality induced by <code>&lt;=</code> and <code>&gt;=</code>
should be identical to that of <code>==</code></h5></div>
<div class="panel "><ul>
<li><code class="inset ">a &lt;= b</code> and <code class="inset ">a &lt; b || a == b</code> should give the same answer</li>

<li><code class="inset ">a &gt;= b</code> and <code class="inset ">a &gt; b || a == b</code> should give the same answer</li></ul></div>
<div class="panel-fold bullet " ><h5 class="nav-none">Make all comparison functions <em>noexcept</em></h5></div>
<div class="panel vcompact"><h6 class="nav-none">Comparison operations should never encounter exceptional situations:</h6>
<ul>
<li><p>Comparisons must always be <em>read-only</em> operations</p>
<ul class="cbullets "><li class="follows ">no out-of-memory errors</li>
<li class="follows ">no file access errors</li>
&hellip;</ul></li>

<li><p>No problem, if (part) of a value is not available 
(e.g., internal memory buffer not yet allocated, file not opened, &hellip;)</p>
<ul>
<li>both values not available &rArr; equal</li>

<li>one value available, one not available &rArr; not equal</li>

<li>both values available &rArr; compare values</li></ul></li></ul></div></div></div></section>
<section class="epilog">
<div class="panel-col bg-filled"{style=""><div class="guide-nav">
<div class="go-prev"><a href="cpp/lang/friends.html"><span class="hwide">friend</span></a></div>
<div class="go-up"><a href="cpp/beginners_guide.html#custom-types-1">Beginner's Guide <span class="hxwide">/ Custom Types 1</span></a></div>
<div class="go-next"><a href="cpp/design/literal_types.html"><span class="hwide">Literal Types</span></a></div>
</div></div>
</section>
<section class="epilog">
<div class="panel-fold " open><h3 class="cat-link">Related <span class="if-closed">&hellip;</span></h3></div>
<div class="panel "><ul class="resources "><li class="cat-youtube"><a href="https://youtu.be/0SeUPb8LC9I">C++ Weekly: Short Intro To <code>operator&lt;=&gt;</code></a></li>
<li class="cat-cppreference"><a href="https://en.cppreference.com/w/cpp/language/default_comparisons">cppreference: Default Comparisons in C++20</a></li>
<hr>
<li class="cat-isostd"><a href="http://eel.is/c++draft/class.spaceship">C++ Standard: Three-way comparison</a></li>
<li class="cat-isostd"><a href="http://eel.is/c++draft/class.compare.default">C++ Standard: Defaulted comparison operator functions</a></li></ul></div>
</section>
<section class="context">
<ul class="linear-tags "><li><a href="tags/c++.html">C++</a></li><li><a href="tags/c++20.html">C++20</a></li><li><a href="tags/article.html">article</a></li><li><a href="tags/beginner-level.html">beginner-level</a></li><li><a href="tags/classes.html">classes</a></li><li><a href="tags/comparisons.html">comparisons</a></li><li><a href="tags/custom-types.html">custom-types</a></li><li><a href="tags/types.html">types</a></li></ul>
</section>
<section class="metadata">
<p><span class="cat-date">Last updated: 2021-01-10</span></p>
</section>
</article></div>
<footer>
<div id="footer-top"><div id="footer-top-content"><div id="footer-top-left"><nav><ul class="plain ">
<li>
<a href="index.html" class="cat-home" >Home</a>
</li>

<li>
<a href="tags/news.html" class="cat-news" >News</a>
</li>

<li>
<a href="tags/article.html" class="cat-article" >Articles</a>
</li>

<li>
<a href="tags/featured.html" class="cat-featured" >Featured</a>
</li>

<li>
<a href="tags/guide.html" class="cat-guide" >Guides</a>
</li>

<li>
<a href="tags/list.html" class="cat-list" >Lists</a>
</li>

<li>
<a href="about.html" class="cat-about" >About</a>
</li>

<li>
<a href="privacy.html" class="cat-contact" >Privacy</a>
</li>

<li>
<a href="https://twitter.com/hackingcpp" class="cat-twitter" >Twitter</a>
</li></ul></nav></div>
<div id="footer-top-right"><h2 class="cat-tags nav-none">
<a href="tags.html" >Tags</a>
</h2>
<ul class="topic-cloud "><li><a style="font-size:119.09832775265055%;" href="tags/algorithms.html">algorithms</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/allocators.html">allocators</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/arrays.html">arrays</a></li> <li><a style="font-size:155.67625418551208%;" href="tags/article.html">article</a></li> <li><a style="font-size:151.4520701280242%;" href="tags/beginner-level.html">beginner-level</a></li> <li><a style="font-size:60.0%;" href="tags/blogs.html">blogs</a></li> <li><a style="font-size:60.0%;" href="tags/books.html">books</a></li> <li><a style="font-size:60.0%;" href="tags/build-systems.html">build-systems</a></li> <li><a style="font-size:160.9530933887302%;" href="tags/c++.html">C++</a></li> <li><a style="font-size:60.0%;" href="tags/c++-standardization.html">C++-standardization</a></li> <li><a style="font-size:122.76135311474769%;" href="tags/c++11.html">C++11</a></li> <li><a style="font-size:112.96632221214513%;" href="tags/c++14.html">C++14</a></li> <li><a style="font-size:104.32374581448789%;" href="tags/c++17.html">C++17</a></li> <li><a style="font-size:109.08009883059783%;" href="tags/c++20.html">C++20</a></li> <li><a style="font-size:60.0%;" href="tags/c++98.html">C++98</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/c-style.html">C-style</a></li> <li><a style="font-size:60.0%;" href="tags/c-vs-c++.html">C-vs-C++</a></li> <li><a style="font-size:60.0%;" href="tags/cat-casts.html">cat-casts</a></li> <li><a style="font-size:106.83431667163975%;" href="tags/classes.html">classes</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/code-editors.html">code-editors</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/code-formatters.html">code-formatters</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/command-line.html">command-line</a></li> <li><a style="font-size:106.83431667163975%;" href="tags/community.html">community</a></li> <li><a style="font-size:60.0%;" href="tags/comparisons.html">comparisons</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/compilers.html">compilers</a></li> <li><a style="font-size:60.0%;" href="tags/concepts.html">concepts</a></li> <li><a style="font-size:60.0%;" href="tags/conferences.html">conferences</a></li> <li><a style="font-size:60.0%;" href="tags/const.html">const</a></li> <li><a style="font-size:60.0%;" href="tags/constexpr.html">constexpr</a></li> <li><a style="font-size:111.11165590902733%;" href="tags/containers.html">containers</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/control-flow.html">control-flow</a></li> <li><a style="font-size:114.67244982290701%;" href="tags/custom-types.html">custom-types</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/data-structures.html">data-structures</a></li> <li><a style="font-size:60.0%;" href="tags/debugging.html">debugging</a></li> <li><a style="font-size:104.32374581448789%;" href="tags/design.html">design</a></li> <li><a style="font-size:106.83431667163975%;" href="tags/diagnostics.html">diagnostics</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/exceptions.html">exceptions</a></li> <li><a style="font-size:89.54916387632527%;" href="tags/featured.html">featured</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/file-io.html">file-io</a></li> <li><a style="font-size:60.0%;" href="tags/find.html">find</a></li> <li><a style="font-size:60.0%;" href="tags/find_if.html">find_if</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/functional-prog.html">functional-prog</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/functions.html">functions</a></li> <li><a style="font-size:60.0%;" href="tags/gallery.html">gallery</a></li> <li><a style="font-size:94.30551689243521%;" href="tags/generic-prog.html">generic-prog</a></li> <li><a style="font-size:60.0%;" href="tags/groups.html">groups</a></li> <li><a style="font-size:60.0%;" href="tags/guide.html">guide</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/guidelines.html">guidelines</a></li> <li><a style="font-size:60.0%;" href="tags/hash-map.html">hash-map</a></li> <li><a style="font-size:60.0%;" href="tags/hash-set.html">hash-set</a></li> <li><a style="font-size:60.0%;" href="tags/hashing.html">hashing</a></li> <li><a style="font-size:60.0%;" href="tags/header-files.html">header-files</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/heap.html">heap</a></li> <li><a style="font-size:60.0%;" href="tags/ides.html">ides</a></li> <li><a style="font-size:98.1917402739825%;" href="tags/idiom.html">idiom</a></li> <li><a style="font-size:98.1917402739825%;" href="tags/io.html">io</a></li> <li><a style="font-size:94.30551689243521%;" href="tags/iostreams.html">iostreams</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/iterators.html">iterators</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/language-mechanism.html">language-mechanism</a></li> <li><a style="font-size:60.0%;" href="tags/language-references.html">language-references</a></li> <li><a style="font-size:60.0%;" href="tags/learning.html">learning</a></li> <li><a style="font-size:60.0%;" href="tags/libraries.html">libraries</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/linker.html">linker</a></li> <li><a style="font-size:130.25147500745962%;" href="tags/list.html">list</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/low-level.html">low-level</a></li> <li><a style="font-size:60.0%;" href="tags/map.html">map</a></li> <li><a style="font-size:109.08009883059783%;" href="tags/memory.html">memory</a></li> <li><a style="font-size:120.39055466724817%;" href="tags/modern-c++.html">modern-C++</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/move-semantics.html">move-semantics</a></li> <li><a style="font-size:126.83373677211958%;" href="tags/news.html">news</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/oop.html">oop</a></li> <li><a style="font-size:60.0%;" href="tags/organizations.html">organizations</a></li> <li><a style="font-size:60.0%;" href="tags/package-manager.html">package-manager</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/paradigm.html">paradigm</a></li> <li><a style="font-size:60.0%;" href="tags/pattern.html">pattern</a></li> <li><a style="font-size:60.0%;" href="tags/people.html">people</a></li> <li><a style="font-size:60.0%;" href="tags/podcasts.html">podcasts</a></li> <li><a style="font-size:60.0%;" href="tags/pointers.html">pointers</a></li> <li><a style="font-size:60.0%;" href="tags/preprocessor.html">preprocessor</a></li> <li><a style="font-size:60.0%;" href="tags/profiling.html">profiling</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/randomness.html">randomness</a></li> <li><a style="font-size:60.0%;" href="tags/ranges.html">ranges</a></li> <li><a style="font-size:60.0%;" href="tags/references.html">references</a></li> <li><a style="font-size:60.0%;" href="tags/set.html">set</a></li> <li><a style="font-size:60.0%;" href="tags/social-media.html">social-media</a></li> <li><a style="font-size:60.0%;" href="tags/sorted-sequences.html">sorted-sequences</a></li> <li><a style="font-size:89.54916387632527%;" href="tags/stack.html">stack</a></li> <li><a style="font-size:60.0%;" href="tags/standardization.html">standardization</a></li> <li><a style="font-size:116.25207726360686%;" href="tags/std-algorithms.html">std-algorithms</a></li> <li><a style="font-size:89.54916387632527%;" href="tags/std-containers.html">std-containers</a></li> <li><a style="font-size:128.6110337848704%;" href="tags/std-library.html">std-library</a></li> <li><a style="font-size:60.0%;" href="tags/std-macros.html">std-macros</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/std-vector.html">std-vector</a></li> <li><a style="font-size:60.0%;" href="tags/strings.html">strings</a></li> <li><a style="font-size:60.0%;" href="tags/style.html">style</a></li> <li><a style="font-size:60.0%;" href="tags/taste.html">taste</a></li> <li><a style="font-size:83.41715833581988%;" href="tags/templates.html">templates</a></li> <li><a style="font-size:60.0%;" href="tags/testing.html">testing</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/toolchain.html">toolchain</a></li> <li><a style="font-size:116.25207726360686%;" href="tags/tools.html">tools</a></li> <li><a style="font-size:74.77458193816263%;" href="tags/traversal.html">traversal</a></li> <li><a style="font-size:117.72267522825506%;" href="tags/types.html">types</a></li> <li><a style="font-size:60.0%;" href="tags/user.html">user</a></li> <li><a style="font-size:60.0%;" href="tags/version-control.html">version-control</a></li> <li><a style="font-size:60.0%;" href="tags/views.html">views</a></li> <li><a style="font-size:60.0%;" href="tags/vim.html">VIM</a></li> <li><a style="font-size:60.0%;" href="tags/vim-plugins.html">VIM-plugins</a></li> <li><a style="font-size:60.0%;" href="tags/warnings.html">warnings</a></li> <li><a style="font-size:114.67244982290701%;" href="tags/websites.html">websites</a></li> 
</ul></div></div></div>
<div id="footer-bottom"><div id="footer-bottom-content">&copy;&nbsp;2019-2021&ensp;André&nbsp;Müller&emsp;&emsp;</div></div>
</footer>
<script src="assets/content.js?v=26"></script>
</body>
</html>